
---
title: Redis——事件
date: 2021-06-18 22:46:25
updated: 2021-06-18 22:46:29
tags:
    - 学习
categories:
    - Redis
---
# 概述

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

- 文件事件（file event）：Redis服务器通过套接字与客户端（或其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作
- 时间事件（time event）：Redis服务器中的一些操作（如serveCron）函数需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象

# 文件事件

Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称作为文件事件处理器：

- 文件事件处理器使用I/O多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 当被监听的套接字准备好执行连接应答（accept）读取（read）写入（write）关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件

虽然文件事件处理器是以单线程方式运行，但通过使用I/O多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好的与Redis服务器中其他同样以单线程方试运行的模块进行对接，这保持了Redis内部单线程设计的简单性。

## 文件事件处理器的构成

{% asset_img image-20210617171226039.png Hash:20210617171226039  %}

尽管多个文件事件可能会并发地出现，单I/O多路复用程序总是将所有产生事件的套接字都放到一个队列里，以有序、同步、每次一个套接字的方式，向文件事件分排气传送套接字。当上一个套接字产生的时间被处理完之后，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字

## I/O多路复用程序的实现

Redis的I/O多路复用程序的所有功能都是通过包装常见的***select、epoll、evport、kqueue***这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如 <u>***ae_select.c、ae_epoll.c、ae_kqueue.c***</u>。因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的。程序会在编译时自动选择系统中性能最高的I/O多路复用函数库来作为Redis的I/O多路复用程序的底层实现。

## 事件的类型

I/O多路复用程序可以监听多个套接字的 <u>***ae.h/AE_READABLE***</u> 事件和 <u>***ae.h/AE_WRITABLE***</u> 事件，这两类事件和套接字操作之间关系：

- 当套接字变得可读时（客户端对套接字执行write操作或者close操作）或者有新的可应答套接字出现（客户端执行connect操作），套接字产生***AE_READABLE***事件
- 套接字变得可写时（客户端对套接字执行read操作），套接字产生***AE_WRITABLE***事件

I/O多路复用程序允许服务器同时监听套接字的这两个事件，如果一个套接字同时产生了这两种事件，那么文件事件分配器会优先处理***AE_READABLE***事件，处理完之后再处理***AE_WRITABLE***事件。
`也就是说，如果一个套接字可读又可写，那么先读套接字，再写套接字`

## 文件事件的处理器

Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求。在这些事件处理器里面，服务器最常用的是与客户端进行通信的连接应答处理器、命令请求处理器和命令回复处理器。

### 连接应答处理器

<u>***networking.c/acceptTcpHandler***</u> 函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现是 <u>***sys/socket.h/accept***</u>函数的包装。

`套接字产生AE_READABLE事件，引发连接应答处理器执行`

### 命令请求处理器

<u>***networking.c/readQueryFromClient***</u> 函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容，具体实现是 <u>***unistd.h/read***</u>函数的包装。

`套接字产生AE_READABLE事件，引发命令请求处理器执行`

### 命令回复处理器

<u>***networking.c/sendReplyToClient***</u>函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现是 <u>***unistd.h/write***</u>函数的包装。

`套接字产生AE_WRITABLE事件，引发命令请求处理器执行`

{% asset_img image-20210618141938482.png Hash:20210618141938482  %}

# 时间事件

Redis的时间事件分为以下两类：

- 定时事件：让一段程序在指定的时间之后执行一次：让程序X在当前时间的30ms后执行一次
- 周期性事件：让一段程序每隔指定时间就执行一次：让程序Y每隔30ms执行一次

一个时间事件主要由以下三个属性组成:

- id:服务器为时间事件创建的全局唯一ID（标识号），该ID递增。
- when：毫秒精度的UNIX时间戳，记录了时间事件的到达时间
- timePro：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。

一个时间事件是定时的还是周期性的取决于时间事件处理器的返回值：

- 如果事件处理器返回***ae.h/AE_NOMORE*** ,那么这个事件为定时事件：该事件在达到一次后就会被删除，之后不再到达。
- 如果返回了一个非***AE_NOMORE*** 的其他整数值，那么这个事件为周期性事件：到达后服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段事件后再次到达，并以这种方式一直进行下去。

## 实现

​	服务器把所所有的时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就***遍历整个链表***，查找所有已到达的时间事件，并调用相应的事件处理器。

`无序链表并不影响时间事件处理器的性能,因为Redis正常模式下只有一个serverCron一个时间事件，benchmark模式下，Redis也只是用两个时间事件`

## 时间事件应用实例：serverCron函数

持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 <u>***redis.c/serverCron***</u>函数负责执行。主要工作：

- 更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等
- 清理数据库中过期的键值对
- 关闭和清理连接失效的客户端
- 尝试进行AOF和RDB持久化操作
- 如果服务器是主服务器，那么对从服务器进行定义同步
- 如果处于集群模式，对集群进行定期同步和连接测试

Redis以周期性事件的方式来运行***serverCron***函数，在服务器运行期间，每隔一段时间就会运行一次***serverCron***。

用户可以通过修改 <u>***redis.conf/hz***</u>选项修改***serverCron***执行次数。

# 重点回顾

- Redis服务器是一个事件驱动程序，服务器处理的事件分为时间事件与文件事件
- 文件事件处理器是基于Reactor模式实现的网络通信程序
- 文件事件是对套接字操作的抽象：每次套接字变为可应答、可写、可读的时候，相应的文件事件就会产生
- 文件事件分为***AE_READABLE***（读事件）和***AE_WRITABLE***（写事件）
- 时间事件分为定时事件与周期性事件
- 服务器在一般情况下只执行***serverCron***函数这一个时间事件
- 文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占
- 时间事件的实际处理时间通常会比设定的到达时间晚一些

