
---
title: Redis——事务
date: 2021-07-13 22:46:25
updated: 2021-07-13 22:46:29
tags:
    - 学习
categories:
    - Redis
---

# 概述

Redis通过***MULTI、EXEC、WATCH*** 等命令来实现事务功能。事务提供了一种将多个命令请求打包,然后按照原子性，一致性地执行多个命令。并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

以下是一个事务执行的过程，该事务首先以一个 MULTI命令为开始，接着将多个命令放入事务当中，最后由 EXEC 命令将这个事务提交（commit）给服务器执行。

```shell
redis> MULTI
OK
redis>SET "name" "Practical Common Lisp"
QUEUED
redis>GET "name"
QUEUED
redis>SET "author" "Peter Seibel"
QUEUED

redis>GET "author"
QUEUED

redis> EXEC
1) OK
2) "Practical Common Lisp"
3）OK
4）"Peter Seibel"
```



# 事务的实现

一个事务从开始到结束通常要经历三个阶段：事物开始；命令入队；事务执行。

## 事务开始

***MULTI*** 命令的执行标志着事务的开始(类似数据库的start transaction)：

```shell
redis>MULTI
OK
```

***MULTI*** 命令将执行命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性，打开***REDIS_MULTI***标识来完成。

## 命令入队

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。

与此不同的是，当一个客户端切换到事务状态之后，服务器会根据这个客户端发来的不同命令执行不同的操作：

- 如果客户端发送的是***EXEC、DISCARD、WATCH、MULTI***四个命令中的其中一个，那么服务器立即执行这个命令。
- 如果是其他的命令，服务器并不会立即执行这个命令，而是将这个命令放入一个事务队列里，然后向客户端返回QUEUED回复。

## 事务队列

每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的mstate属性里。

事务状态包含一个事务队列，以及一个已入队命令的计数器（也可以说是事务队列的长度）。

事务队列是一个multiCmd类型的数组，数组中的每个multiCmd结构都保存了一个已入队命令的相关信息，包括指向命令实现函数的指针、命令的参数，以及参数的数量：

```c
typedef struct redisClient{
  //...
  //事务状态
  multiState mstate;
  //...
}redisClient;

typedef struct multiState{
  // 事务队列，FIFO顺序
  multiCmd *commands;
  // 已入队命令计数
  int count;
}multiState;

typedef struct multiCmd{
  // 参数
  robj **argv;
  // 参数数量
  int argc;
  // 命令指针
  struct redisCommand *cmd;
}multiCmd;
```

事务队列以先进先出（FIFO）的方式保存入队的命令。

## 执行事务

当一个处于事务状态的客户端向服务器发送EXEC命令时，这个***EXEC***（类似commit） 命令将立即被执行。然后服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得到的结果全部返回给客户端。

# WATCH 命令的实现

***WATCH*** 是一个乐观锁，它可以在***EXEC*** 命令执行之前，监事任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过，如果是，服务器将拒绝执行事务，并向客户端返回代表执行事务失败的空回复。

| 时间 | 客户端A            | 客户端B           |
| ---- | ------------------ | ----------------- |
| T1   | WATCH "name"       |                   |
| T2   | MULTI              |                   |
| T3   | SET "name" "peter" |                   |
| T4   |                    | SET "name" "john" |
| T5   | EXEC               |                   |

```shell
redis>WATCH "name"
OK
redis> MULTI
OR
redis> SET "name" "peter"
QUEUED

redis> EXEC
(ni1)
```

在时间 T4，客户端B修改了 "name"键的值，当客户端A在T5执行 EXEC 命令时，
服务器会发现 WATCH监视的键"name"已经被修改，因此服务器拒绝执行客户端A的事务，并向客户端A返回空回复。

## 使用WATCH命令监视数据库键

每个Redis数据库都保存着一个***watched_keys*** 字典，这个字典的键就是某个被***WATCH*** 命令监视的数据库键，而字典的值则是一个记录了所有监视相应数据库键的客户端的链表。

通过***watched_keys***字典，服务器可以清除的知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。

当客户端使用watch命令时，服务器则会在watched_keys字典中，把客户端与被监视的键进行关联。

## 监视机制的触发

所有对数据库进行修改的命令，如***SET、LPUSH、SADD、ZREM、DEL、FLUSHDB*** 等等，在执行之后，都会调用***multi.c/touchWatchKey*** 函数对***watched_keys*** 字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么***touchWatchKey*** 函数会将监视被修改键的客户端的***REDIS_DIRTY_CAS***标识打开，标识该客户端的事务安全性已经被破坏。

## 判断事务是否安全

当服务器接受到一个客户端发来的***EXEC***命令时，服务器会根据这个客户端是否打开了***REDIS_DIRTY_CAS*** 标识来决定是否执行。

如果该标识已经被打开，说明在客户端监视的键中，至少有一个已经被修改过了，那么客户端提交的事务已经不再安全，所以服务器会拒绝执行客户端提交的事务。

反之则会执行。

# 事务的ACID性质

## 原子性

如果一个事务因为命令入队出错而被服务器拒绝执行，那么事务中所有的命令都不会被执行。

```shell
redis> MULTI
OK
redis> SET msg "hello"
QUEUED
redis>GET
(error) ERR wrong number of arguments for 'get' command

redis> GET msg
QUEUED

redis>EXEC
(error) EXECABORT Transaction discarded because of previous errors.
```

如果是因为事务队列中某个命令在执行期间出错，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕。

```shell
redis> SET msg "hello" # msg 键是一个字符串
OK
redis> MULTI
OK
redis> SADD fruit "apple" "banana" "cherry"
OUEUED

redis> RPUSH msg "good bye" "bye bye" # 错误地对字符串键nsg 执行列表键的命令
QUEUED

redis> SADD alphabet "a" "b" "c"
QUEUED
redis>EXEC
1)(integer) 3
2)(error) WRONGTYPE Operation against a key holding the wrong kind of value
3)(integer) 3
```

Redis 的作者在事务功能的文档中解释说，不支持事务回滚是因为这种复杂的功能和Redis 追求简单高效的设计主旨不相符，并且他认为，Redis 事务的执行时错误通常都是编程错误产生的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能。

## 一致性

事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。

### 入队错误

如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，那么Redis将拒绝执行这个事务。

因为在事务队列里，会记录命令的实现函数，命令参数，命令参数个数等信息，所以可以判断出命令是否有问题。

`Redis 2.6.5 以前的入队错误处理
根据文档记录，在 Redis 2.6.5 以前的版本，即使有命令在入队过程中发生了错误，
事务一样可以执行，不过被执行的命令只包括那些正确入队的命令。`

### 执行错误

除了入队时可能发生错误以外，事务还可能在执行的过程中发生错误。

执行过程中发生的错误都是一些不能在入队时就被服务器发现的错误，这些错误只会在命令实际执行时被触发。

即使在事务的执行过程中发生了错误，服务器也不会中断事务的执行，它会继续执
行事务中余下的其他命令，并且已执行的命令（包括执行命令所产生的结果）不会
被出错的命令影响。

### 服务器宕机

如果Redis服务器在执行事务的过程中宕机，那么根据服务器所使用的持久化模式，可能有以下情况出现：

- 如果服务器运行在无持久化的内存模式下，那么重启之后的数据库将是空白的，因此数据一致。
- 如果运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 RDB 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 RDB 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。
- 如果服务器运行在 AOF 模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的 AOF 文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的 AOF 文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的。

## 隔离性

事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。
因为 Redis 使用单线程的方式来执行事务（以及事务队列中的命令），并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis 的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。

## 持久性

事务的持久性指的是，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（比如硬盘）里面了，即使服务器在事务执行完毕之后停机，执行事务所得的结果也不会丢失。

因为Redis的事务不过是简单地用队列包裹一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的持久性由Redis所使用的持久化模式决定的：

- 当服务器在无持久化的内存模式下运作时，事务不具有持久性：一旦服务器停机，包括事务数据在内的所有服务器数据都将丢失。
- 当服务器在 RDB 持久化模式下运作时，服务器只会在特定的保存条件被满足时，才会执行 BGSAVE 命令，对数据库进行保存操作，并且异步执行的 BGSAVE 不能保正事务数据被第一时间保存到硬盘里面，因此 RDB 持久化模式下的事务也不具有耐久性。
- 当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 always 时，程序总会在执行命令之后调用同步（sync）函数，将命令数据真正地保存到硬盘里面，因此这种配置下的事务是具有持久性的。
- 当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 everysec时，程序会每秒同步一次命令数据到硬盘。因为停机可能会恰好发生在等待同步的那一秒钟之内，这可能会造成事务数据丢失，所以这种配置下的事务不具有持久性。
- 当服务器运行在 AOF 持久化模式下，并且 appendfsync 选项的值为 no时，程序会交由操作系统来决定何时将命令数据同步到硬盘。因为事务数据可能在等待同步的过程中丢失，所以这种配置下的事务不具有耐久性。

### no-appendfsync-on-rewrite配置选项对耐久性的影响

配置选项 ***no-appendfsync-on-rewrite*** 可以配合 appendfsync 选项
为 always 或者 everysec 的 AOF 持久化模式使用。当***no-appendfsync-on-rewrite***选项处于打开状态时，在执行 BGSAVE 命令或者 BGREWRITEAOF 命令期
间，服务器会暂时停止对 AOF 文件进行同步，从而尽可能地减少TO 阻塞。但是这样一来，关于“always 模式的 AOF 持久化可以保证事务的耐久性”这一结论将不再成立，因为在服务器停止对 AOF 文件进行同步期间，事务结果可能会因为停机而丢失。因此，如果服务器打开了 ***no-appendfsync-on-rewrite*** 选项，那么即使服务器运行在 always 模式的 AOF 持久化之下，事务也不具有耐久性。在默认配置下，***no-appendfsyne-on-rewrite*** 处于关闭状态。

# 重点回顾

- 事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。
- 多个命令会被入队到事务队列中，然后按照先进先出的顺序执行
- 事务在执行的过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束
- 带有WATCH命令的事务会将客户端和被监视的键在数据库的***watch_keys*** 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的***REDIS_DIRTY_CAS*** 标志打开
- 只有在客户端的 ***REDIS_DIRTY_CAS*** 标志未被打开时，服务器才会执行客户端提交的事务，否则的话，服务器将拒绝执行客户端提交的事务。
- Redis 的事务总是具有 ACID 中的原子性、一致性和隔离性，当服务器运行在 AOF持久化模式下，并且 appendfsync 选项的值为 always 时，事务也具有耐久性。

