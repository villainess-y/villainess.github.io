<!DOCTYPE html><html lang="zh_CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="王花菇与叶香橼"><meta name="copyright" content="王花菇与叶香橼"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>Redis——六：对象 | 王花菇的小站</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="icon" href="/villainess.github.io/yun.svg"><link rel="mask-icon" href="/villainess.github.io/yun.svg" color="#0078E7"><link rel="alternate icon" href="/villainess.github.io/yun.ico"><link rel="preload" href="/villainess.github.io/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/villainess.github.io/js/utils.js" as="script"><link rel="preload" href="/villainess.github.io/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/villainess.github.io/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"github.com","root":"/villainess.github.io/","title":"王花菇与叶香橼","version":"1.6.1","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/villainess.github.io/css/hexo-theme-yun.css"><script src="/villainess.github.io/js/utils.js"></script><script src="/villainess.github.io/js/hexo-theme-yun.js"></script><meta name="description" content="概述​        Redis并没有直接使用前面介绍的SDS,跳表，字典，压缩链表，整数集合等数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种类型的对象，每个对象都用到了至少一种前面介绍的数据结构。 ​        通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis——六：对象">
<meta property="og:url" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/%E5%85%AD%EF%BC%9A%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="王花菇的小站">
<meta property="og:description" content="概述​        Redis并没有直接使用前面介绍的SDS,跳表，字典，压缩链表，整数集合等数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象这五种类型的对象，每个对象都用到了至少一种前面介绍的数据结构。 ​        通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609162339053.png">
<meta property="og:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609162841624.png">
<meta property="og:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609163741336.png">
<meta property="og:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609163851700.png">
<meta property="og:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609165540223.png">
<meta property="article:published_time" content="2021-06-15T14:46:25.000Z">
<meta property="article:modified_time" content="2021-06-15T14:46:29.000Z">
<meta property="article:author" content="王花菇与叶香橼">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/villainess-y/villainess.github.io/2021/06/15/images/Redis/image-20210609162339053.png"><script src="/villainess.github.io/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/villainess.github.io/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/villainess.github.io/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/villainess.github.io/about/" title="王花菇与叶香橼"><img width="96" loading="lazy" src="/villainess.github.io/images/author.JPG" alt="王花菇与叶香橼"></a><div class="site-author-name"><a href="/villainess.github.io/about/">王花菇与叶香橼</a></div><span class="site-name">王花菇的小站</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/villainess.github.io/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/villainess.github.io/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/villainess.github.io/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><div class="site-state-item"><a href="/villainess.github.io/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=kZJzggTTCf4SpvEQ8lXWoi5ZjhAx0ILZ&amp;jump_from=webapi" title="QQ 群 1050458482" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/YunYouJun" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/jizhideyunyoujun" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/yunyoujun/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=247102977" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/yunyoujun/" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1579790" title="哔哩哔哩" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/about/white-qrcode-and-search.jpg" title="微信公众号" target="_blank" style="color:#1AAD19"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-2-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/YunYouJun" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://t.me/elpsycn" title="Telegram Channel" target="_blank" style="color:#0088CC"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-telegram-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:me@yunyoujun.cn" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://travellings.now.sh/" title="Travelling" target="_blank" style="color:var(--hty-text-color)"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-send-plane-2-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/villainess.github.io/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">对象的类型与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">编码和底层实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">编码的转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">列表对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.</span> <span class="toc-text">编码转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%93%BE%E8%A1%A8"><span class="toc-number">4.2.</span> <span class="toc-text">快速链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">哈希对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">5.1.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">6.1.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">有序集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">为什么有序集合需要同时使用跳表和字典来实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-3"><span class="toc-number">7.2.</span> <span class="toc-text">编码转换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%A4%9A%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">类型检查与命令多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.1.</span> <span class="toc-text">类型检查的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.</span> <span class="toc-text">多态命令的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">9.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">10.</span> <span class="toc-text">对象共享</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A9%BA%E8%BD%AC%E6%97%B6%E9%95%BF"><span class="toc-number">11.</span> <span class="toc-text">对象的空转时长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-number">12.</span> <span class="toc-text">重点回顾</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://github.com/villainess-y/villainess.github.io/villainess.github.io/2021/06/15/%E5%85%AD%EF%BC%9A%E5%AF%B9%E8%B1%A1/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="王花菇与叶香橼"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="王花菇的小站"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Redis——六：对象</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2021-06-15 22:46:25" itemprop="dateCreated datePublished" datetime="2021-06-15T22:46:25+08:00">2021-06-15</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/villainess.github.io/categories/Redis/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">Redis</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/villainess.github.io/tags/%E5%AD%A6%E4%B9%A0/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">学习</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>​        Redis并没有直接使用前面介绍的SDS,跳表，字典，压缩链表，整数集合等数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<em><strong>字符串对象</strong></em>、<em><strong>列表对象</strong></em>、<em><strong>哈希对象</strong></em>、<em><strong>集合对象</strong></em>、<em><strong>有序集合</strong></em>对象这五种类型的对象，每个对象都用到了至少一种前面介绍的数据结构。</p>
<p>​        通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令，可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率</p>
<h1 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h1><p>​        Redis使用对象来表示数据库中的键和值，每次在Redis的数据库中新建一个键值对时，至少会创建两个对象，一个对象用作键(键对象)，另一个用于值(值对象)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">  <span class="comment">//类型</span></span><br><span class="line">  <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">  <span class="comment">//编码</span></span><br><span class="line">  <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">  <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">  <span class="comment">// void *ptr;</span></span><br><span class="line">  ....</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><table>
<thead>
<tr>
<th align="center">类型常量</th>
<th align="center">对象的名称</th>
<th>TYPE命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_STRING</td>
<td align="center">字符串对象</td>
<td>“string”</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">列表对象</td>
<td>“list”</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">哈希对象</td>
<td>“hash”</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">集合对象</td>
<td>“set”</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">有序集合对象</td>
<td>“zset”</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">键，值均为字符串对象</span></span><br><span class="line">redis &gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">redis &gt; TYPE msg</span><br><span class="line">string</span><br><span class="line"><span class="meta">#</span><span class="bash">键为字符串，值为列表</span></span><br><span class="line">redis &gt; RPUSH numbers 1 3 5</span><br><span class="line">(integer)6</span><br><span class="line">redis &gt; TYPE numbers</span><br><span class="line">list</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>​        对象的prt指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p>
<p>​        表列出了每种类型的对象可以使用的编码</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编码</th>
<th align="center">对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_INT</td>
<td align="center">使用整数值实现的字符串对象</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_EMBSTR</td>
<td align="center">embstr编码的简单动态字符串实现</td>
</tr>
<tr>
<td align="center">REDIS_STRING</td>
<td align="center">REDIS_ENCODING_RAW</td>
<td align="center">简单动态字段实现</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">压缩列表实现</td>
</tr>
<tr>
<td align="center">REDIS_LIST</td>
<td align="center">REDIS_ENCODING_LINKEDLIST</td>
<td align="center">双链表实现</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">压缩列表实现</td>
</tr>
<tr>
<td align="center">REDIS_HASH</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">字典实现</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_INTSET</td>
<td align="center">整数集合实现</td>
</tr>
<tr>
<td align="center">REDIS_SET</td>
<td align="center">REDIS_ENCODING_HT</td>
<td align="center">字典实现</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_ZIPLIST</td>
<td align="center">压缩列表实现</td>
</tr>
<tr>
<td align="center">REDIS_ZSET</td>
<td align="center">REDIS_ENCODING_SKIPLIST</td>
<td align="center">跳表和字典实现</td>
</tr>
</tbody></table>
<p>使用<em><strong>OBJECT ENCODING</strong></em>命令可以查看一个数据库键的值对象的编码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line">redis &gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">redis &gt; SET story &quot;long long long long long ago ....&quot;</span><br><span class="line">OK</span><br><span class="line">redis &gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p>
<ul>
<li>因为压缩列表比双向链表节约内存，所以元素数量少时，在内存中以连续内存块保存可以更快载入到缓存中</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表的优势逐渐消失，对象就会将底层实现从压缩列表转向功能性更强、也适合保存大量元素的双向链表上</li>
</ul>
<h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>字符串对象的编码可以是<em><strong>int</strong></em>、<em><strong>raw</strong></em>或者<em><strong>embstr</strong></em>。</p>
<p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象将会把整数值保存在字符串对象结构的ptr属性里(把void* 转换成long)，并将字符串对象的编码设置为<em><strong>int</strong></em>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis &gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line">redis &gt; OBJECT ENCODING number</span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<p>如果一个字符串对象保存的是一个字符串值，并且这个字符串值的长度大于44字节，那么字符串对象将使用一个SDS来保存这个字符串值，并将对象的编码设置为<em><strong>raw</strong></em>。</p>
<p>如果这个字符串的长度小于44(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33996921/article/details/105226259">最新版本</a>)字节，那么字符串对象将使用<em><strong>embstr</strong></em>编码的方式来保存这个字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; set story &quot;Long, long long long long long long ago ...&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; STRLEN story</span><br><span class="line">(integer) 43</span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line">redis&gt; set story &quot;Long, long long long long long long ago .....&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; STRLEN story</span><br><span class="line">(integer) 45</span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>embstr编码是专门用于保存短字符串的一种优化编码方式，这种编码方式和raw编码方式一样，都使用redisObject结构和sdshdr结构来表示字符串对象，然是raw编码会调用两次内存分配，来分别创建redisObject结构和sdshdr结构，而embstr编码只会调用一次内存分配函数来分配一块连续的空间，空间中依次包含redisObject和sdshdr两个结构。</p>
<p>可以用long double类型表示的浮点数在Redis中也是作为字符串值来保存的，如果我们要保存一个浮点数到字符串对象里，那么程序会先把这个浮点数转成字符串值然后再保存该字符串值</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> <span class="built_in">set</span> pi 3.14</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING pi</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure>

<p>如果需要对浮点型数据进行操作，程序会把字符串对象里的字符串转换回浮点数，执行完操作之后，再转换回字符串，保存在字符串对象里。</p>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>int编码的字符串对象和embstr编码的字符串对象在条件满足的情况下，会被转换为raw编码的字符串对象。</p>
<p>对于int编码的字符串对象，如果执行完操作之后不再是整数值而是字符串值，则对应的字符串对象的编码会从int变成raw。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET number 11</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING number</span></span><br><span class="line">&quot;int&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> APPEND number <span class="string">&quot;is a good number!&quot;</span></span></span><br><span class="line">(integer) 19</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET number</span></span><br><span class="line">&quot;11is a good number!&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING number</span></span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>Redis并没有为embstr编码的字符串对象编写任何的修改程序，所以embstr编码的字符串对象实际上是只读的。让我们使用命令对embstr编码对象执行操作时，程序会先将对象的编码从embstr转换成raw，然后再执行相应的命令。(实际这点并未复现)</p>
<h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象的编码可以是<em><strong>ziplist</strong></em> 或者<em><strong>linkedlist</strong></em>。</p>
<p>ziplist使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素。</p>
<p>linkedlist使用双向链表作为底层实现，每个双向链表节点都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>当列表对象同时满足一下两个条件时，列表对象使用ziplist编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表对象保存的元素数量小于512个；</li>
</ul>
<p>不满足这两个条件的列表对象需要使用linkedlist编码</p>
<p>这两个条件的上限值可以修改，具体看配置文件<u><em><strong>list-max-ziplist-value</strong></em></u>和<u><em><strong>list-max-ziplist-entries</strong></em></u>选项的说明</p>
<h2 id="快速链表"><a href="#快速链表" class="headerlink" title="快速链表"></a>快速链表</h2><p>链表的附加空间相对太高，prev和next指针就要占16字节，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此Redis3.2版本开始对列表数据结构进行了改造，使用<u><em><strong>quicklist</strong></em></u>替代了ziplist和linkedlist。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/12624691.html">快速链表</a></p>
<h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是<u><em><strong>ziplist</strong></em></u>或者<u><em><strong>hashtable</strong></em></u></p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再讲保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧凑在一起，键的节点在前，值的节点在后</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，后添加的会在表尾方向</li>
</ul>
<p><img src="../images/Redis/image-20210609162339053.png" alt="image-20210609162339053" loading="lazy"></p>
<p>HashTable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象，对象中保存了键值对的键</li>
<li>字典的每个值都是一个字符串对象，对象值保存了键值对的值</li>
</ul>
<p><img src="../images/Redis/image-20210609162841624.png" alt="image-20210609162841624" loading="lazy"></p>
<h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足依稀两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</li>
<li>哈希对象保存的键值对数量小于512个</li>
</ul>
<p>不满足这两个条件的哈希对象需要用HashTable编码。</p>
<p>这两个条件的上限值可以修改，具体看配置文件<u><em><strong>hash-max-ziplist-value</strong></em></u>和<u><em><strong>hash-max-ziplist-entries</strong></em></u>选项的说明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book name <span class="string">&quot;mastering C++ in 21 days&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING book</span></span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加一个键长度为66字节</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> HSET book long_long_long_long_long_long_long_long_long_long_long_description <span class="string">&quot;content&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING book</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是<u><em><strong>intset</strong></em></u>或者<u><em><strong>hashtable</strong></em></u></p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Redis/image-20210609163741336.png" alt="image-20210609163741336" loading="lazy"></p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值全部被设置为NULL。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD Dfruits <span class="string">&quot;apple&quot;</span> <span class="string">&quot;banana&quot;</span> <span class="string">&quot;cherry&quot;</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING Dfruits</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Redis/image-20210609163851700.png" alt="image-20210609163851700" loading="lazy"></p>
<h2 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h2><p>当集合对象可以同时满足一下两个条件时，对象使用intset编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过512个</li>
</ul>
<p>不满足这两个条件的集合对象需要使用hashtable编码。</p>
<p>第二个条件的上限值是可以修改的，具体看配置文件中<u><em><strong>set-max_intset-entries</strong></em></u>选项的说明。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers 1 3 5</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合对象的编码可以是<u><em><strong>ziplist</strong></em></u>或者<u><em><strong>skiplist</strong></em></u>。</p>
<p>ziplist编码使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个节点则保存元素的分值。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序，分值小的元素放置在靠近表头的方向，而分值大的元素靠近表尾方向。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT ENCODING price</span></span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p><img src="../images/Redis/image-20210609165540223.png" alt="image-20210609165540223" loading="lazy"></p>
<p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和跳表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span>&#123;</span></span><br><span class="line">	zskiplist *zsl;</span><br><span class="line">	dict *dict;</span><br><span class="line">&#125;zset;</span><br></pre></td></tr></table></figure>

<p>zset结构中的zsl跳表按照分值从小到大保存了所有集合元素，每个跳表节点都保存了一个集合元素：跳表节点的object属性保存了元素的成员，而跳表节点的score属性则保存了元素的分值。通过这个跳表，程序可以对有序集合进行范围型操作。</p>
<p>除此之外，zset结构中的dict字典为有序集合创建了一个从成员到分值的映射，字典中每个键值对都保存了一个集合元素：字典的键是元素的值，而字典的值则是元素的分值。通过这个字典，程序可以O(1)查找给定成员的分值。</p>
<p>有序集合每个元素的成员都是一个字符串对象，而每个元素的分值都是一个double类型的浮点数。虽然zset结构同时使用跳表和字典来保存有序集合元素，但是这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳表和字典来保存元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。</p>
<h2 id="为什么有序集合需要同时使用跳表和字典来实现？"><a href="#为什么有序集合需要同时使用跳表和字典来实现？" class="headerlink" title="为什么有序集合需要同时使用跳表和字典来实现？"></a>为什么有序集合需要同时使用跳表和字典来实现？</h2><p>只使用字典实现有序集合，可以O(1)查找成员的分值，但字典无序，范围性操作会产生额外的时空间复杂度。</p>
<p>只使用跳表，范围性操作优点可以保留，但是查找会从O(1)上升为O(logN)。</p>
<p>综合使用则保留了两种方法的优点。</p>
<h2 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h2><p>当有序集合对象可以同时满足一下两个条件时，对象使用ziplist编码：</p>
<ul>
<li><p>有集合保存的元素数量小于128个；</p>
</li>
<li><p>有序集合保存的所有元素成员的长度都小于64字节</p>
</li>
</ul>
<p>不满足以上两个条件的有序集合对象将使用skiplist编码。</p>
<p>这两个条件的上限值可以修改，具体看配置文件<u><em><strong>zset-max-ziplist-entries</strong></em></u>和<u><em><strong>zset-max-ziplist-value</strong></em></u>选项的说明</p>
<h1 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h1><p>Redis中用于操作键的命令可以分为两种。</p>
<p>一种可以对任何类型的键执行，比如DEL，EXPIRE，RENAME，TYPE，OBJECT.</p>
<p>另一种命令只能对特定类型的键执行：</p>
<ul>
<li>SET    GET    APPEND    STRLEN等只能对字符串键执行；</li>
<li>HDEL、HSET、HGET、HLEN等只能对哈希键执行；</li>
<li>RPUSH、LPOP、LINSERT、LLEN等只能对列表键执行；</li>
<li>SADD、SPOP、SINTER、SCARD等只能对集合键执行；</li>
<li>ZADD、ZCARD、ZRANK、ZSCORE等只能对有序集合键执行；</li>
</ul>
<h2 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h2><p>在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令，通过检查redisObject结构的type属性来实现。</p>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>除了根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<p>如果对一个键执行LLEN命令，那么服务器除了要确保执行命令的键是列表键之外，还要根据键的值对象所使用的编码来选择正确的LLEN命令：</p>
<ul>
<li>如果列表对象的编码是ziplist，那么说明列表对象的实现为压缩列表，程序将使用ziplistLen函数来返回列表的长度；</li>
<li>如果列表对象的编码是linkedList，那么程序将使用listLength函数来返回双向链表的长度；</li>
</ul>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><p>C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个引用计数技术实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="keyword">int</span> refcount;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时，引用计数的值会被初始化为1；</li>
<li>当对象被一个新程序使用时，它的引用计数的值会+1；</li>
<li>当对象不再被一个程序使用时，它的引用计数的值会-1；</li>
<li>当对象的引用计数值为0时，对象所占用的内存会被释放。</li>
</ul>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有对象共享的作用。</p>
<p>如果键A创建一个包含整数值100的字符串对象作为值对象，这时键B也要创建一个同样保存了整数值100的字符串对象作为值对象，那么服务器有两种做法：</p>
<ol>
<li>为键B创建一个100的字符串对象；</li>
<li>让键A和键B共享一个字符串对象。</li>
</ol>
<p>为了节约内存Redis显然是第二中方法：</p>
<ol>
<li>将数据库键指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数+1。</li>
</ol>
<p>目前而言Redis会在初始化服务器的时候创建一万个字符串对象，包含了0~9999所有的整数值，当服务器需要用到这些字符串对象时，服务器就会使用这些共享对象，而不是创建新对象。</p>
<p>这些共享字符串对象的数量可以通过修改<u><em><strong>redis.h/REDIS_SHARED_INTEGERS</strong></em></u>常量来修改。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34839150/article/details/109844848">最新版如果是共享变量，那么引用计数为设置为INT_MAX</a></p>
<h1 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h1><p>除了<u><em><strong>type、encoding、ptr、refcount</strong></em></u>这四个属性之外，还有最有一个为<u><em><strong>lru</strong></em></u>属性，该属性记录了对象最后一次被命令程序访问的时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>

<p>OBJECT IDLETIME命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash">等待几秒</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 12</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再等待几秒</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 23</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> GET msg</span></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 键处于活跃状态，空转时长会重置</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>除了可以被OBJECT IDLETIME命令打印出来之外，键的空转时长还有另一个作用：如果服务器打开了<u><em><strong>maxmemory</strong></em></u>选项，并且服务器用于回收内存的算法为<u><em><strong>volatile-lru</strong></em></u>或者是<u><em><strong>allkeys-lru</strong></em></u>那么当服务器占用内存数超过了<u><em><strong>maxmemory</strong></em></u>选项所设置的上限值时，那么Redis就回回收掉空转时长较高的键值。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis数据库中每个键值对的键和值都是一个对象</li>
<li>Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象都至少有两种以上的编码，不同编码在不同场景上可以优化对象的使用效率</li>
<li>在执行某些命令之前，服务器会先检查键类型是否能执行指定的命令</li>
<li>Redis对象系统带有引用计数实现内存回收机制</li>
<li>Redis会共享值为0~9999的字符串对象</li>
<li>对象会记录自己最后一次被访问的时间，可以用于计算对象的空转时间</li>
</ul>
</div><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none;"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/alipay-qrcode.jpg" alt="支付宝" title="支付宝"></a><div><span style="color:#00A3EE"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/qqpay-qrcode.png" alt="QQ 支付" title="QQ 支付"></a><div><span style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></span></div></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/donate/wechatpay-qrcode.jpg" alt="微信支付" title="微信支付"></a><div><span style="color:#2DC100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>王花菇与叶香橼</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://github.com/villainess-y/villainess.github.io/2021/06/15/%E5%85%AD%EF%BC%9A%E5%AF%B9%E8%B1%A1/" title="Redis——六：对象">https://github.com/villainess-y/villainess.github.io/2021/06/15/%E5%85%AD%EF%BC%9A%E5%AF%B9%E8%B1%A1/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/villainess.github.io/2021/06/16/hello-world/" rel="prev" title="Hello World"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">Hello World</span></a></div><div class="post-nav-item"></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 王花菇与叶香橼</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.1</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>